#!/usr/node/bin/node
/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2013, Joyent, Inc. All rights reserved.
 *
 */

var assert = require('assert');
var async = require('/usr/node/node_modules/async');
var bunyan = require('/usr/node/node_modules/bunyan');
var cp = require('child_process');
var EventEmitter = require('events').EventEmitter;
var log = bunyan.createLogger({level: 'debug', name: 'vmload-driver', serializers: bunyan.stdSerializers});
var getVmobj = require('vmload').getVmobj;
var getZoneRecords = require('vmload-zoneadm').getZoneRecords;
var spawn = cp.spawn;

var zoneevent;
var zpoolevent;

function watchZoneEvents(log)
{
    watchZoneTransitions(function _zoneeventHandler(err, ze) {
        console.log('ZONE EVENT/');
        console.dir(err);
        console.dir(ze);
        console.log('/ZONE EVENT');
    }, log);
}

function watchZpoolEvents(log)
{
    watchZpoolTransitions(function _zpooleventHandler(err, ze) {
        console.log('ZPOOL EVENT/');
        console.dir(err);
        console.dir(ze);
        console.log('/ZPOOL EVENT');
    }, log);
}

// handler() will be called with an object describing the transition for any
// transitions seen (after any filtering).  The only filtering here is to remove
// duplicate events.  Other filtering should be done by the caller.
function watchZoneTransitions(handler, log) {
    var buffer = '';
    var chunks;
    var cleanup;
    var watcher;
    var watcher_pid;

    assert(log, 'no logger passed to watchZoneTransitions()');

    if (!zoneevent) {

        zoneevent = new EventEmitter();

        log.debug('/usr/vm/sbin/zoneevent');
        watcher = spawn('/usr/vm/sbin/zoneevent', [],
            {'customFds': [-1, -1, -1]});
        log.debug('zoneevent running with pid ' + watcher.pid);
        watcher_pid = watcher.pid;

        watcher.stdout.on('data', function (data) {
            var chunk;
            var obj;
            var prev_msg;

            buffer += data.toString();
            chunks = buffer.split('\n');
            while (chunks.length > 1) {
                chunk = chunks.shift();
                obj = JSON.parse(chunk);

                if (obj === prev_msg) {
                    // Note: sometimes sysevent emits multiple events for the
                    // same status, we only want the first one here because just
                    // because sysevent does it, doesn't make it right.
                    log.debug('duplicate zoneevent message! '
                        + JSON.stringify(obj));
                } else if (zoneevent) {
                    zoneevent.emit('zoneevent', null, obj);
                }
            }
            buffer = chunks.pop();
        });

        // doesn't take input.
        watcher.stdin.end();

        watcher.on('exit', function (code) {
            log.warn('zoneevent watcher ' + watcher_pid + ' exited: ',
                JSON.stringify(code));
            // tell all the listeners of this zoneevent (if there are any) that
            // we exited.  Then null it out so next time we'll make a new one.
            zoneevent.emit('zoneevent', new Error('zoneevent watcher exited '
                + 'prematurely with code: ' + code));
            zoneevent = null;
        });
    }

    cleanup = function () {
        var listeners;

        if (zoneevent) {
            listeners = zoneevent.listeners('zoneevent');

            log.debug('cleanup called w/ listeners: '
                + util.inspect(listeners));
            zoneevent.removeListener('zoneevent', handler);
            if (zoneevent.listeners('zoneevent').length === 0) {
                log.debug('zoneevent watcher ' + watcher_pid
                    + ' cleanup called');
                zoneevent = null;
                if (watcher) {
                    watcher.stdout.destroy(); // so we don't send more 'data'
                    watcher.stderr.destroy();
                    watcher.removeAllListeners('exit'); // so don't fail on kill
                    watcher.kill();
                    watcher = null;
                }
            }
        } else if (watcher) {
            watcher.stdout.destroy(); // so we don't send more 'data'
            watcher.stderr.destroy();
            watcher.removeAllListeners('exit'); // so don't fail on our kill
            watcher.kill();
            watcher = null;
        }
    };

    zoneevent.on('zoneevent', handler);

    return ({'cleanup': cleanup});
}

function watchZpoolTransitions(handler, log)
{
    var buffer = '';
    var chunks;
    var cleanup;
    var cmd = '/usr/sbin/dtrace';
    var cmdargs = ['-q', '-n',
        'fbt::spa_history_log:entry {printf("%s\\n", stringof(arg1))}'];
    var cmdline;
    var watcher;
    var watcher_pid;

    assert(log, 'no logger passed to watchZpoolTransitions()');

    if (!zpoolevent) {

        zpoolevent = new EventEmitter();

        cmdline = cmd + ' ' + cmdargs.join(' ');
        log.debug(cmdline);
        watcher = spawn(cmd, cmdargs, {'customFds': [-1, -1, -1]});
        log.debug('zpool watcher running with pid ' + watcher.pid);
        watcher_pid = watcher.pid;

        watcher.stdout.on('data', function (data) {
            var chunk;
            var obj;
            var prev_msg;

            buffer += data.toString();
            chunks = buffer.split('\n');
            while (chunks.length > 1) {
                zpoolevent.emit('zpoolevent', null, chunks.shift());
            }
            buffer = chunks.pop();
        });

        watcher.stderr.on('data', function (data) {
            console.log(data.toString());
        });


        // doesn't take input.
        watcher.stdin.end();

        watcher.on('exit', function (code) {
            log.warn('zpoolevent watcher ' + watcher_pid + ' exited: ',
                JSON.stringify(code));
            // tell all the listeners of this zpoolevent (if there are any) that
            // we exited.  Then null it out so next time we'll make a new one.
            zpoolevent.emit('zpoolevent', new Error('zpoolevent watcher exited '
                + 'prematurely with code: ' + code));
            zpoolevent = null;
        });
    }

    cleanup = function () {
        var listeners;

        if (zpoolevent) {
            listeners = zpoolevent.listeners('zpoolevent');

            log.debug('cleanup called w/ listeners: '
                + util.inspect(listeners));
            zpoolevent.removeListener('zpoolevent', handler);
            if (zpoolevent.listeners('zpoolevent').length === 0) {
                log.debug('zpoolevent watcher ' + watcher_pid
                    + ' cleanup called');
                zpoolevent = null;
                if (watcher) {
                    watcher.stdout.destroy(); // so we don't send more 'data'
                    watcher.stderr.destroy();
                    watcher.removeAllListeners('exit'); // so don't fail on kill
                    watcher.kill();
                    watcher = null;
                }
            }
        } else if (watcher) {
            watcher.stdout.destroy(); // so we don't send more 'data'
            watcher.stderr.destroy();
            watcher.removeAllListeners('exit'); // so don't fail on our kill
            watcher.kill();
            watcher = null;
        }
    };

    zpoolevent.on('zpoolevent', handler);

    return ({'cleanup': cleanup});
}


getZoneRecords(null, {log: log}, function (err, results) {
    var last_vm;
    var vms;

    if (err) {
        throw err;
    }

    vms = Object.keys(results);

    // start watchers
    watchZoneEvents(log);
    watchZpoolEvents(log);

    /*
    async.eachSeries(vms, function (uuid, cb) {
        console.log('LOADING: ' + uuid);
        getVmobj(uuid, {log: log}, function (err, obj) {
            console.log(JSON.stringify(obj, null, 2));
            cb();
        });
    }, function (err) {
        console.log('DONE');
    });
    */

});
