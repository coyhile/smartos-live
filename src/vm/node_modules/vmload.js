#!/usr/node/bin/node
/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2013, Joyent, Inc. All rights reserved.
 *
 */

var assert = require('assert');
var async = require('/usr/node/node_modules/async');
var bunyan = require('/usr/node/node_modules/bunyan');
var fs = require('fs');
var getDatasets = require('vmload-datasets').getDatasets;
var getVmobjJSON = require('vmload-json').getVmobjJSON;
var getVmobjXML = require('vmload-xml').getVmobjXML;
var getZoneRecords = require('vmload-zoneadm').getZoneRecords;
var path = require('path');
var props = require('/usr/vm/node_modules/props');
var utils = require('utils');

var assertSafeZonePath = utils.assertSafeZonePath;
var trim = utils.trim;

// load generated tables of data
var BRAND_OPTIONS = props.BRAND_OPTIONS;

var DISABLED = false;

var dataset_objects;
var sysinfo;
var vm_objects = {};
var zoneadm_objects;


// TODO: this function is way too long
function addDatasetProperties(vmobj, dsinfo, options, callback) {
    var dsname;
    var dsobj;
    var d;
    var delegated;
    var disk;
    var ds;
    var filesys;
    var friendly_snap;
    var friendly_snapshots = [];
    var log;
    var matches;
    var raw_snapshots = [];
    var snap;
    var snap_time;

    log = options.log;

    if (dsinfo.hasOwnProperty('mountpoints')
        && dsinfo.hasOwnProperty('datasets')
        && dsinfo.mountpoints.hasOwnProperty(vmobj.zonepath)) {

        dsname = dsinfo.mountpoints[vmobj.zonepath];
        dsobj = dsinfo.datasets[dsname];

        /* dsobj.quota is in bytes, we want GiB for vmobj.quota */
        if (wantField(options, 'quota') && dsobj.hasOwnProperty('quota')) {
            vmobj.quota = (dsobj.quota / (1024 * 1024 * 1024));
            log.trace('found quota "' + vmobj.quota + '" for '
                + vmobj.uuid);
        }

        if (wantField(options, 'create_timestamp')
            && !vmobj.hasOwnProperty('create_timestamp')
            && dsobj.hasOwnProperty('creation')) {

            log.debug('VM has no create_timestamp, using creation '
                + 'from ' + dsobj.name);
            vmobj.create_timestamp =
                (new Date(dsobj.creation * 1000)).toISOString();
        }

        if (wantField(options, 'zfs_root_compression')
            && dsobj.hasOwnProperty('compression')
            && (dsobj.compression !== 'off')) {

            vmobj.zfs_root_compression = dsobj.compression;
        }

        if (wantField(options, 'zfs_root_recsize')
            && dsobj.hasOwnProperty('recsize')) {

            vmobj.zfs_root_recsize = dsobj.recsize;
        }

        // Always add zfs_filesystem if we can because it's needed
        // to find other properties such as delegated_dataset.
        vmobj.zfs_filesystem = dsobj.name;

        if (wantField(options, 'snapshots')
            && dsinfo.hasOwnProperty('snapshots')
            && dsinfo.snapshots
            .hasOwnProperty(vmobj.zfs_filesystem)) {

            raw_snapshots = raw_snapshots.concat(
                dsinfo.snapshots[vmobj.zfs_filesystem]);
        }

        log.trace('found dataset "' + vmobj.zfs_filesystem
            + '" for ' + vmobj.uuid);
    } else {
        log.trace('no dsinfo for ' + vmobj.uuid + ': '
            + vmobj.zonepath);
    }

    // delegated datasets are keyed on the dataset name instead of
    // mountpoint, since mountpoint can change in a zone.
    if (vmobj.hasOwnProperty('zfs_filesystem')) {
        delegated = vmobj.zfs_filesystem + '/data';
        if (dsinfo.datasets.hasOwnProperty(delegated)) {
            dsobj = dsinfo.datasets[delegated];

            if (dsobj.hasOwnProperty('compression')
                && (dsobj.compression !== 'off')) {

                vmobj.zfs_data_compression = dsobj.compression;
            }
            if (dsobj.hasOwnProperty('recsize')) {
                vmobj.zfs_data_recsize = dsobj.recsize;
            }

            // If there are snapshots for this dataset, add them
            if (DISABLED) {
                // XXX currently only support snapshot on
                // zfs_filesystem
                if (dsinfo.hasOwnProperty('snapshots')
                    && dsinfo.snapshots.hasOwnProperty(delegated)) {

                    raw_snapshots = raw_snapshots
                        .concat(dsinfo.snapshots[delegated]);
                }
            }
        } else {
            log.trace('no dsinfo for delegated dataset: '
                + delegated);
        }

        vmobj.zpool =
            vmobj.zfs_filesystem.split('/')[0];
    }

    if (wantField(options, 'disks') && vmobj.hasOwnProperty('disks')) {
        for (d in vmobj.disks) {
            d = vmobj.disks[d];
            if (d.hasOwnProperty('path')
                && dsinfo.mountpoints.hasOwnProperty(d.path)) {

                dsname = dsinfo.mountpoints[d.path];
                dsobj = dsinfo.datasets[dsname];

                if (dsobj.hasOwnProperty('volsize')) {

                    /* dsobj.volsize is in bytes, we want MiB */
                    d.size = (dsobj.volsize / (1024 * 1024));
                    log.debug('found size=' + d.size + ' for '
                        + JSON.stringify(d));
                }
                if (dsobj.hasOwnProperty('compression')) {
                    d.compression = dsobj.compression;
                }
                if (dsobj.hasOwnProperty('refreservation')) {
                    /* dsobj.refreservation is in bytes, want MiB */
                    d.refreservation
                        = (dsobj.refreservation / (1024 * 1024));
                    log.debug('found refreservation='
                        + d.refreservation + ' for '
                        + JSON.stringify(d));
                }
                if (dsobj.hasOwnProperty('volblocksize')) {
                    d.block_size = dsobj.volblocksize;
                }

                // If there are snapshots for this dataset, add them
                // to the list.
                if (DISABLED) {
                    // XXX currently only support snapshots on
                    //     zfs_filesystem
                    if (dsinfo.hasOwnProperty('snapshots')
                        && dsinfo.snapshots.hasOwnProperty(
                            d.zfs_filesystem)) {

                        raw_snapshots = raw_snapshots.concat(dsinfo
                            .snapshots[d.zfs_filesystem]);
                    }
                }
            } else if (d.hasOwnProperty('path')) {
                d.missing = true;
            } else {
                log.warn('no dsinfo and no path for '
                    + JSON.stringify(d));
            }
        }
    }

    // snapshots here is the raw list of snapshots, now we need to
    // convert it to the "friendly" list of snapshots.
    if (wantField(options, 'snapshots')) {
        for (snap in raw_snapshots) {
            snap = raw_snapshots[snap];

            matches = snap.snapname.match(/^vmsnap-(.*)$/);
            if (matches && matches[1]) {
                friendly_snap = {name: matches[1]};
                if (snap.hasOwnProperty('created_at')) {
                    snap_time
                        = new Date(snap.created_at * 1000); // in ms
                    friendly_snap.created_at
                        = snap_time.toISOString();
                }
                friendly_snapshots.push(friendly_snap);
            } else {
                log.debug('ignoring unfriendly ' + snap.snapname);
                continue;
            }
        }
        // sort the snapshots with newest first.
        friendly_snapshots.sort(function (a, b) {
            if (a.created_at > b.created_at) {
                return -1;
            }
            if (a.created_at < b.created_at) {
                return 1;
            }
            return 0; // equal
        });
        vmobj.snapshots = friendly_snapshots;
    }

    if (vmobj.state === 'receiving') {
        vmobj.missing = { 'datasets': [], 'disks': [],
            'filesystems': [] };
        if (!fs.existsSync(vmobj.zonepath)) {
            vmobj.missing.datasets.push(vmobj.zonepath.substr(1));
        }
        for (ds in vmobj.datasets) {
            ds = vmobj.datasets[ds];
            vmobj.missing.datasets.push(ds);
        }
        for (filesys in vmobj.filesystems) {
            filesys = vmobj.filesystems[filesys];
            if (filesys.hasOwnProperty('source')) {
                vmobj.missing.filesystems.push(filesys.source);
            }
        }
        for (disk in vmobj.disks) {
            disk = vmobj.disks[disk];
            if (disk.hasOwnProperty('missing')) {
                vmobj.missing.disks.push(disk.path);
            }
        }
    }

    callback();
}

function getPid(zonepath, pidfile, options, callback) {
    var filename = path.join(zonepath, 'root', pidfile);
    var log = options.log;
    var zoneroot = path.join(zonepath, '/root');

    // ensure pid_file is safe
    try {
        assertSafeZonePath(zoneroot, pidfile, {type: 'file', enoent_ok: true});
    } catch (e) {
        callback(e);
        return;
    }

    // XXX trace
    log.debug('looking for KVM PID in ' + filename);

    fs.readFile(filename, function (error, filedata) {
        var pid;

        if (error) {
            callback(error);
            return;
        }

        pid = Number(trim(filedata.toString()));
        if (pid <= 0) {
            callback(new Error('found invalid PID ' + pid + ' in ' + filename));
            return;
        }

        // XXX trace
        log.debug('found PID ' + pid + ' in ' + filename);
        callback(null, pid);
    });
}

function wantField(options, field) {
    if (options.hasOwnProperty('fields')
        && options.fields.indexOf(field) === -1) {

        return false;
    }
    return true;
}

function getSysinfo(log, callback) {
    var filename = '/tmp/.sysinfo.json';

    // XXX we take a shortcut here and read from the cache file the sysinfo
    //     tool maintains. This allows us to also watch for changes to that
    //     file and update our cache.
    fs.readFile(filename, function (error, filedata) {
        var pid;

        if (error) {
            callback(error);
            return;
        }

        // XXX should we remove this try here so we just blow up?
        try {
            // sysinfo is global in this module
            sysinfo = JSON.parse(filedata.toString());
        } catch (e) {
            callback(e);
            return;
        }

        callback();
    });
}

function getLastModified(zonename, zonepath, log)
{
    var files = [];
    var file;
    var stat;
    var timestamp = 0;

    assert(log, 'no logger passed to getLastModified()');

    if (zonepath) {
        files.push(path.join(zonepath, '/config/metadata.json'));
        files.push(path.join(zonepath, '/config/routes.json'));
        files.push(path.join(zonepath, '/config/tags.json'));
    } else {
        log.debug('getLastModified() no zonepath!');
    }

    if (zonename) {
        files.push('/etc/zones/' + zonename + '.xml');
    } else {
        log.debug('getLastModified() no zonename!');
    }

    for (file in files) {
        file = files[file];
        try {
            stat = fs.statSync(file);
            if (stat.isFile()) {
                if ((timestamp === 0) || (Date.parse(stat.mtime) > timestamp)) {
                    timestamp = Date.parse(stat.mtime);
                }
            }
        } catch (e) {
            if (e.code !== 'ENOENT') {
                log.error(e, 'Unable to get timestamp for "' + file + '":'
                    + e.message);
            }
        }
    }

    return ((new Date(timestamp)).toISOString());
}

/*
 * getVmobjs is used to lookup *the list* of VMs that match the specified
 * filters. The "filters" parameter is an array of functions.
 *
 * Starting with an array of all VMs on this node, the VM objects are passed
 * one at a time through the filter functions. If the function returns a true
 * value, it will be included in the list passed to the next function. If it
 * returns a false-y value, it will not.
 *
 * So for example if we start with a list of VMs:
 *
 *   [ A, B, C, D ]
 *
 * and we get a list of filters:
 *
 *   [ func1, func2, func3 ]
 *
 * func1 will be called with:
 *
 *   func1(vmobj, callback)
 *
 * for *all* VMs. func2 will only be called with the set of VMs for which func1
 * returned 'true'. If the array of VMs remaining becomes empty, further
 * functions will not be called.
 *
 * Each of these functions must call callback(<true|false>) after making their
 * determination.
 *
 * callback will be called with an error when there is an internal error or an
 * error with your options / match_fields, but not when no VMs match. In that
 * case callback will still be called, but with an empty array as the second
 * argument.
 *
 */
function getVmobjs(filter, options, callback) {
    var log;
    var vmobjs = [];

    assert(typeof (filter) === 'function', 'filter must be a function');
    assert(options.log, 'no logger passed to getVmobj()');
    log = options.log;

    // TODO: when options.sync is set, use getZoneRecords, otherwise use
    //       just those VMs in vm_objects

    getZoneRecords(null, {log: log}, function (error, results) {
        if (error) {
            throw error;
        }

        vms = Object.keys(results);
        async.eachSeries(vms, function (uuid, cb) {
            getVmobj(uuid, {log: log}, function (err, obj) {
                if (err) {
                    cb(err);
                    return;
                }
                vmobjs.push(obj);
                cb();
            });
        }, function (err) {
            if (err) {
                callback(err);
                return;
            }

            async.filterSeries(vmobjs, filter, function (results) {
                callback(null, results);
            });
        });
    });
}

function getVmobj(uuid, options, callback) {
    var log;
    var sync = false;
    var vmobj = {};
    var zoneadm_info;

    assert(options.log, 'no logger passed to getVmobj()');
    log = options.log;

    log.trace('getting vmobj for VM ' + uuid);

    // TODO:
    //
    //  "lock" option which allows us to complete one w/ cache so all are faster
    //  "force" option which bypasses cache and loads again
    //  "fields" option which defines which fields we want in objects
    //  "nocache" option which doesn't cache the results and when fields are
    //     specified, avoids getting data that's not needed for this request
    //
    // break out the zoneadm loading and dataset loading to external functions
    // so we can call those ahead of time (ie. at vminfo boot) to pre-warm the
    // cache.
    //
    // break out "updater" function so we can pass in updates on events like:
    //
    //  - snapshot was created (zfs events)
    //  - snapshot was deleted (zfs events)
    //  - vm state changed (zoneevent)
    //  - {tags,metadata,routes}.json file changed (fs.watchers)
    //  - xml changes (fs.watchers)
    //  - QMP comes up w/ HWSetup (poller)
    //  - /var/svc/provisioning file moves
    //  - ...
    //
    // and update the appropriate cached values.
    //
    // setup periodic re-check.
    //

    // XXX should we assume someone's been keeping cache up to date?
    sync = true; // XXX this is until we have options.sync=true or actual cache
    if (sync === false) {
        if (vm_objects.hasOwnProperty(uuid)) {
            log.trace({uuid: uuid}, 'returning vmobj from cache');
            callback(null, vm_objects[uuid]);
            return;
        } else {
            // TODO: return ENOENT or fallback to slow way?
        }
    }

    async.series([
        function (cb) {
            // load data from zoneadm list -pc (or cache)

            if (sync === false && zoneadm_objects) {
                log.trace({uuid: uuid}, 'returning zoneadm_info from cache');
                zoneadm_info = zoneadm_objects[uuid];
                // TODO: assert zoneadm_info
                cb();
                return;
            }

            // XXX if nocache, should send uuid as first arg
            getZoneRecords(null, {log: log}, function (err, results) {
                var new_err;
                var vmobj = {};

                if (err) {
                    cb(err);
                    return;
                }

                zoneadm_objects = results;
                zoneadm_info = zoneadm_objects[uuid];

                if (!zoneadm_info) {
                    new_err = new Error('VM ' + uuid + ' not found in zoneadm');
                    new_err.code = 'ENOENT';
                    cb(new_err);
                    return;
                }

                // TODO: assert zoneadm_info

                cb();
                return;
            });
        }, function (cb) {
            // XXX need to also allow this cache to be updated
            if (!sysinfo) {
                getSysinfo(log, cb);
                return;
            }
            cb();
        }, function (cb) {
            // load data from /etc/zones/<zonename>.xml
            getVmobjXML(uuid, {log: log}, function (err, obj) {
                if (!err) {
                    vmobj = obj;
                }
                cb(err);
            });
        }, function (cb) {
            // We got some bits from `zoneadm list` in zoneadm_info here, and
            // since we already got that data, adding it to the object here is
            // cheap. We also need some of these properties to be able to get
            // others later, so we add them all now. If they're unwanted they'll
            // be removed from the final object.
            vmobj.uuid = zoneadm_info.uuid;
            vmobj.zone_state = zoneadm_info.state;

            if (wantField(options, 'zoneid') && zoneadm_info.zoneid !== '-') {
                vmobj.zoneid = zoneadm_info.zoneid;
            }

            if (wantField(options, 'last_modified')) {
                vmobj.last_modified = getLastModified(vmobj.zonename,
                    vmobj.zonepath, log);
            }

            // If we want resolvers, (eg. OS-2194) we always add the array here
            // so you can tell that the resolvers are explicitly not set.
            if (wantField(options, 'resolvers') && !vmobj.hasOwnProperty('resolvers')) {
                vmobj.resolvers = [];
            }

            // Always include firewall_enabled
            if (wantField('firewall_enabled')
                && !vmobj.hasOwnProperty('firewall_enabled')) {

                vmobj.firewall_enabled = false;
            }

            // sysinfo has server_uuid and potentially some DC info
            if (sysinfo) {
                if (wantField('server_uuid')
                    && sysinfo.hasOwnProperty('UUID')) {

                    vmobj.server_uuid = sysinfo.UUID;
                }
                if (wantField('datacenter_name')
                    && sysinfo.hasOwnProperty('Datacenter Name')) {

                    vmobj.datacenter_name = sysinfo['Datacenter Name'];
                }
                if (wantField('platform_buildstamp')
                    && sysinfo.hasOwnProperty('Live Image')) {

                    vmobj.platform_buildstamp = sysinfo['Live Image'];
                }
                if (wantField('headnode_id')
                    && sysinfo.hasOwnProperty('Headnode ID')) {

                    vmobj.headnode_id = sysinfo['Headnode ID'];
                }
            }

            // state could already be set here if it was overriden by a
            // transition that's in progress. So we only change if that's not
            // the case.
            if (wantField(options, 'state')) {
                if (!vmobj.hasOwnProperty('state')) {
                    if (zoneadm_info.state === 'installed') {
                        vmobj.state = 'stopped';
                    } else {
                        vmobj.state = zoneadm_info.state;
                    }
                }

                // If the zone has the 'failed' property it doesn't matter what
                // other state it might be in, we list its state as 'failed'.
                if (vmobj.failed) {
                    vmobj.state = 'failed';
                }
            }

            cb();
        }, function (cb) {
            // XXX validate we have the following:
            if ((options.hasOwnProperty('fields') && options.fields.indexOf('pid') === -1)
                || !BRAND_OPTIONS[vmobj.brand].hasOwnProperty('features')
                || !BRAND_OPTIONS[vmobj.brand].features.pid_file
                || vmobj.zone_state !== 'running') {

                cb();
                return;
            }

            getPid(vmobj.zonepath, BRAND_OPTIONS[vmobj.brand].features.pid_file,
                options, function (err, pid) {

                // Note we simply log errors here rather than bailing because
                // PIDs are here for information not as an essential part of the
                // VM (it could have stopped) so we don't want to skip loading
                // the VM.
                if (err) {
                    log.error({err: err}, 'failed to load PID for '
                        + vmobj.uuid);
                } else {
                    vmobj.pid = pid;
                }

                cb();
            });
        }, function (cb) {
            var types;

            types = [
                'customer_metadata',
                'internal_metadata',
                'routes',
                'tags'
            ];

            // XXX we pass in options for log + fields
            // XXX we are loading this fully each time, do we want to cache?
            getVmobjJSON(vmobj.zonepath, options, function (err, results) {
                if (err) {
                    /*
                     * when zone_state is 'incomplete' we could be deleting it
                     * in which case metadata may already be gone, ignore
                     * failure to load mdata when 'incomplete' because of this.
                     */
                    if (vmobj.zone_state === 'incomplete') {
                        log.debug({err: error}, 'zone is in state incomplete '
                            + 'ignoring error loading JSON');
                        cb();
                    } else {
                        cb(error);
                    }
                    return;
                }

                // whatever we got back, add to the VM object
                types.forEach(function (m) {
                    if (results.hasOwnProperty(m)) {
                        vmobj[m] = results[m];
                    }
                });

                cb();
            });
        }, function (cb) {
            // load ZFS dataset data (root, delegated, disks, snapshots)
            if (dataset_objects) {
                log.debug('using cached dataset_objects');
                addDatasetProperties(vmobj, dataset_objects, options, cb);
                return;
            } else {
                getDatasets(options, function (err, results) {
                    if (err) {
                        cb(err);
                        return;
                    }
                    dataset_objects = results;
                    addDatasetProperties(vmobj, dataset_objects, options, cb);
                });
            }
        }
    ], function (err) {
        if (err) {
            callback(err);
            return;
        }
        vm_objects[uuid] = vmobj;
        callback(null, vmobj);
    });
}

module.exports = {
    getVmobj: getVmobj,
    getVmobjs: getVmobjs
};
